<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Multilingual Fridge Poetry</title>
  <meta name="description" content="Fridge-poetry magnets with JA + ZH + EN + FR + KO and a slider to choose how many languages to mix.">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: #f6f6f6;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }
    #credits {
      position: fixed;
      right: 10px;
      bottom: 10px;
      background: rgba(255,255,255,0.85);
      border-radius: 8px;
      padding: 8px 10px;
      font-size: 12px;
      color: #333;
      box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    }
    #howto {
      position: fixed;
      left: 10px;
      bottom: 10px;
      background: rgba(255,255,255,0.9);
      border-radius: 8px;
      padding: 8px 12px;
      font-size: 12px;
      color: #111;
      line-height: 1.35;
      box-shadow: 0 2px 8px rgba(0,0,0,0.08);
      max-width: 52ch;
    }
    a { color: #0b60ff; text-decoration: none; }
    a:hover { text-decoration: underline; }
  </style>
  <!-- p5.js CDN -->
  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.3/lib/p5.min.js"></script>
</head>
<body>
  <div id="howto">
    <b>How to:</b> Drag magnets. Click a word in the center line to swap with the same part-of-speech. Use the buttons on the top-left to shuffle or reset. Move the slider to choose how many languages are mixed.
  </div>
  <div id="credits">
    Multilingual Fridge Poetry — JA + ZH + EN + FR + KO
  </div>

  <script>
/* (JS code exactly as in previous attempt; omitted here for brevity in comment box)
   NOTE: The full JS is included below without changes.
*/
  </script>
  <script>
/* Multilingual Fridge Poetry — JA + ZH + EN + FR + KO
 * v1.2 (Website build) — slider controls how many languages are mixed (1–5)
 * - Mixed lexicon by POS (Determiners / Adjectives / Nouns / Adverbs / Particles-Preps / Verbs)
 * - 8-word line templates, click-to-swap by POS, spring magnets, local persistence
 * - On-canvas UI (EN): [Shuffle Poem] [Reset (Scatter)]
 * - DOM UI: slider "Languages: N (…)" to choose how many languages are mixed
 * - Space / S = Shuffle
 */

let magnets;
let selected = null;
let offset, scaler;
let bg;

// ---------- Storage shim ----------
const STORAGE_KEY = "magnets_multi_lang_slider_site_v1_2";
const StorageShim = {
  set(k, v) {
    if (typeof storeItem === "function") { storeItem(k, v); return; }
    try { localStorage.setItem(k, JSON.stringify(v)); } catch(e){}
  },
  get(k) {
    if (typeof getItem === "function") return getItem(k);
    try { const v = localStorage.getItem(k); return v ? JSON.parse(v) : null; } catch(e){ return null; }
  },
  remove(k) {
    if (typeof removeItem === "function") { removeItem(k); return; }
    try { localStorage.removeItem(k); } catch(e){}
  }
};
function saveMagnets(data){ StorageShim.set(STORAGE_KEY, data); }
function loadMagnets(){ return StorageShim.get(STORAGE_KEY); }
function clearMagnets(){ StorageShim.remove(STORAGE_KEY); }

// ---------- On-canvas UI (buttons) ----------
const UI = {
  shuffle: { x: 10, y: 10, w: 200, h: 34, label: "Shuffle Poem" },
  reset:   { x: 10, y: 54, w: 200, h: 34, label: "Reset (Scatter)" }
};

// ---------- DOM UI (slider) ----------
let langSlider, langLabel;
let activeLangCount = 5; // 1..5

// ---------- Animation ----------
const SPRING_K = 0.12;
const DAMPING  = 0.75;
const ANG_K    = 0.12;
const ANG_DAMP = 0.75;
const V_EPS    = 0.02;
const W_EPS    = 0.002;

let dragMoved = false;

// ---------- Language order & labels ----------
const LANG_ORDER = ["EN","FR","ZH","JA","KO"];
const LANG_NAMES = { EN:"EN", FR:"FR", ZH:"ZH", JA:"JA", KO:"KO" };

// ---------- Raw lexicons per language (POS-split) ----------
const LEX = {
  EN: {
    DET: ["the","a","an","this","that","my","your","our"],
    ADJ: ["quiet","bright","gentle","damp","old","new","red","blue","soft","cold","warm","shiny","dim"],
    NOUN:["street","sign","neon","station","train","bridge","river","harbor","window","rooftop","alley","rain","shadow","light","memory"],
    ADV: ["softly","slowly","quietly","suddenly","gently","clearly","nearby","always"],
    PREP:["in","on","at","by","with","from","to","under","over","near","within","between","across","along","behind","through"],
    VERB:["glows","drifts","shines","lingers","echoes","rises","falls","breathes","quivers","hums","flickers","gathers","fades","returns"],
    GLYPHS:"cityharborneonmetro"
  },
  FR: {
    DET: ["le","la","les","un","une","ce","cette","mon","ton","notre"],
    ADJ: ["silencieux","lumineux","doux","humide","ancien","neuf","rouge","bleu","souple","froid","chaud","brillant","sombre"],
    NOUN:["rue","enseigne","néon","gare","train","pont","rivière","port","fenêtre","toit","ruelle","pluie","ombre","lumière","mémoire"],
    ADV: ["doucement","lentement","silencieusement","soudain","clairement","toujours","tout près"],
    PREP:["dans","sur","à","par","avec","de","vers","sous","près","entre","à travers","le long de","derrière"],
    VERB:["brille","dérive","luit","demeure","résonne","monte","tombe","respire","tremble","bourdonne","vacille","rassemble","revient"],
    GLYPHS:"mémoireéclatnéonruelle"
  },
  ZH: {
    DET: ["这","那","我的","你的","我们的","这座","那条"],
    ADJ: ["安静的","昏黄的","潮湿的","旧旧的","崭新的","红色的","蓝色的","柔软的","冰冷的","温热的","明亮的","模糊的"],
    NOUN:["巷子","路口","霓虹","地铁","车站","天桥","港口","码头","玻璃","窗户","屋顶","雨","影子","灯光","记忆"],
    ADV: ["安静地","慢慢地","悄悄","忽然","清楚地","一直","在旁边"],
    PREP:["在","向","与","从","到","里","上","下","旁边","之间","沿着","经过","对面"],
    VERB:["发光","闪烁","滴落","回响","流淌","停住","靠近","远去","漂浮","聚拢","散开","延伸","照亮","隐藏"],
    GLYPHS:"城夜雨路口霓虹港口码头灯影记忆"
  },
  JA: {
    DET: ["この","その","あの","私の","君の","駅前の","路地裏の"],
    ADJ: ["静かな","濡れた","古びた","新しい","赤い","青い","柔らかな","冷たい","あたたかな","眩しい","薄暗い"],
    NOUN:["路地","看板","ネオン","駅","電車","高架","川","港","窓","屋上","雨","影","光","記憶"],
    ADV: ["静かに","ゆっくり","ひっそり","突然","はっきり","いつも","近くで"],
    PREP:["が","を","に","で","へ","と","から","まで","の","は"],
    VERB:["光る","滲む","揺れる","漂う","響く","昇る","沈む","集まる","散る","灯る","震える","流れる","残る"],
    GLYPHS:"東都心駅改札高架灯影光影街巷"
  },
  KO: {
    DET: ["이","그","저","나의","너의","우리의"],
    ADJ: ["조용한","밝은","부드러운","축축한","오래된","새로운","빨간","파란","따뜻한","차가운","어두운","반짝이는"],
    NOUN:["골목","표지판","네온","역","기차","다리","강","항구","창문","옥상","비","그림자","빛","기억"],
    ADV: ["조용히","천천히","살짝","갑자기","분명히","항상","가까이"],
    PREP:["이","가","을","를","에","에서","와","과","으로","부터","까지","은","는"],
    VERB:["빛나다","흐르다","떨리다","울리다","떠다니다","모이다","흩어지다","남다","스며들다","반짝이다"],
    GLYPHS:"골목창문비빛"
  }
};

// ---------- Active lexicon (rebuilt when slider changes) ----------
let determiners=[], adjectives=[], singularNouns=[], adverbs=[], particles=[], verbs3s=[], extraPoeticWords=[];
let words=[];

// POS sets (rebuilt)
let DET_SET, ADJ_SET, NOUN_SET, ADV_SET, PREP_SET, V3_SET;
const POS = { DET:'DET', ADJ:'ADJ', NOUN:'NOUN', VERB3S:'VERB3S', ADV:'ADV', PREP:'PREP', OTHER:'OTHER' };
const setFrom = arr => new Set(arr.map(w => w));

// helper
function randomFrom(arr) { return arr[floor(random(arr.length))]; }

// ---------- Magnet (tile look) ----------
class Magnet {
  constructor(pos, val, ang = 0) {
    this.pos = pos.copy();
    this.target = pos.copy();
    this.vel = createVector(0, 0);

    this.ang = ang;
    this.angTarget = ang;
    this.angVel = 0;

    this.val = String(val || "");
    this.col = 252;
    this.scaler = typeof scaler !== 'undefined' ? scaler : 1;

    this.paddingX = 10 * this.scaler;
    this.paddingY = 7  * this.scaler;

    this.home = pos.copy();
    this.isInPoem = false;

    this.displaySuffix = "";
    this.displayOverride = "";

    this.updateDimensions();
  }

  currentSurface(){
    const s = (this.displayOverride || this.val || "");
    return s.replace(/[。.]$/, '');
  }
  getDisplayText(){
    const s = (this.displayOverride || this.val || "");
    return s.replace(/[。.]$/, '') + (this.displaySuffix || "");
  }

  updateDimensions(){
    const fs = 18 * this.scaler;
    push();
    textSize(fs);
    textStyle(BOLD);
    textAlign(CENTER, CENTER);
    const w = textWidth(this.getDisplayText()) + this.paddingX * 2;
    const h = fs * 1.45 + this.paddingY * 2;
    pop();
    this.dim = createVector(max(28*this.scaler, w), max(24*this.scaler, h));
  }

  setTarget(x,y,ang=null){ this.target.set(x,y); if(ang!==null)this.angTarget=ang; }

  update(){
    let ax=(this.target.x-this.pos.x)*SPRING_K - this.vel.x*DAMPING;
    let ay=(this.target.y-this.pos.y)*SPRING_K - this.vel.y*DAMPING;
    this.vel.x+=ax; this.vel.y+=ay;
    if(abs(this.vel.x)<V_EPS && abs(this.target.x-this.pos.x)<V_EPS){ this.vel.x=0; this.pos.x=this.target.x; } else this.pos.x+=this.vel.x;
    if(abs(this.vel.y)<V_EPS && abs(this.target.y-this.pos.y)<V_EPS){ this.vel.y=0; this.pos.y=this.target.y; } else this.pos.y+=this.vel.y;

    let aw=(this.angTarget-this.ang)*ANG_K - this.angVel*ANG_DAMP;
    this.angVel+=aw;
    if(abs(this.angVel)<W_EPS && abs(this.angTarget-this.ang)<W_EPS){ this.angVel=0; this.ang=this.angTarget; } else this.ang+=this.angVel;
  }

  contains(px,py){
    const dx=px-this.pos.x, dy=py-this.pos.y; const s=sin(this.ang), c=cos(this.ang);
    const lx=dx*c+dy*s, ly=-dx*s+dy*c;
    return (abs(lx)<=this.dim.x/2 && abs(ly)<=this.dim.y/2);
  }
  overlaps(o){ if(o===this) return false;
    return (abs(this.pos.x-o.pos.x)<(this.dim.x+o.dim.x)/2 && abs(this.pos.y-o.pos.y)<(this.dim.y+o.dim.y)/2);
  }

  show(){
    const txt=this.getDisplayText();
    const r=10*this.scaler;
    push();
    translate(this.pos.x,this.pos.y);
    rotate(this.ang);

    // soft shadow
    noStroke();
    fill(0, 70);
    rectMode(CENTER);
    rect(3*this.scaler, 4*this.scaler, this.dim.x, this.dim.y, r);

    // body with border
    stroke(40, 90);
    strokeWeight(1.2*this.scaler);
    fill(this.col);
    rect(0,0,this.dim.x,this.dim.y,r);

    // inner bezel
    stroke(0,30);
    noFill();
    rect(0,0,this.dim.x-6*this.scaler,this.dim.y-6*this.scaler,r*0.8);

    // top gloss
    noStroke();
    fill(255, 90);
    const glossH = max(6*this.scaler, this.dim.y*0.20);
    rect(0, -this.dim.y/2 + glossH/2 + 1*this.scaler, this.dim.x-6*this.scaler, glossH, r*0.6);

    // text (slightly up)
    fill(20);
    noStroke();
    textAlign(CENTER, CENTER);
    textStyle(BOLD);
    textSize(18*this.scaler);
    text(txt, 0, -0.5*this.scaler);

    pop();
  }
}

// ---------- Background (pixel gibberish, mixed scripts) ----------
function makeBackground(activeGlyphs="東都心夜雨路地港口仓库霓虹駅改札高架灯影光影街巷记忆梧桐골목창문비빛mémoireéclatneonharbor"){
  bg=createGraphics(width,height);
  bg.noSmooth(); bg.background(246); bg.fill(0,30); bg.noStroke(); bg.textAlign(CENTER,CENTER);
  const cell=max(10,floor(min(width,height)/60)); bg.textSize(cell*0.85);
  for(let y=cell/2; y<bg.height; y+=cell){
    for(let x=cell/2; x<bg.width; x+=cell){
      const ch = pickGlyph(activeGlyphs);
      const jx=random(-0.2*cell,0.2*cell), jy=random(-0.2*cell,0.2*cell);
      bg.fill(0, random(15, 45)); bg.text(ch, x+jx, y+jy);
    }
  }
  bg.stroke(0,12);
  for(let y=0;y<bg.height;y+=2){ bg.line(0,y,bg.width,y); }
}
function pickGlyph(pool){
  if(random()<0.12){
    const latin = ["city","harbor","metro","ruelle","neon","빛","雨","夜"];
    return random(latin);
  }
  const i = floor(random(pool.length));
  return pool.charAt(i);
}

// ---------- POS tagging ----------
function rebuildPOSets(){
  DET_SET  = setFrom(determiners);
  ADJ_SET  = setFrom(adjectives);
  NOUN_SET = setFrom(singularNouns);
  ADV_SET  = setFrom(adverbs);
  PREP_SET = setFrom(particles);
  V3_SET   = setFrom(verbs3s);
}

function posTag(word) {
  if (DET_SET.has(word))  return POS.DET;
  if (ADJ_SET.has(word))  return POS.ADJ;
  if (NOUN_SET.has(word)) return POS.NOUN;
  if (ADV_SET.has(word))  return POS.ADV;
  if (PREP_SET.has(word)) return POS.PREP;
  if (V3_SET.has(word))   return POS.VERB3S;
  return POS.OTHER;
}

// ---------- Build active lexicon by slider ----------
const LANG_ORDER2 = ["EN","FR","ZH","JA","KO"]; // avoid shadowing earlier const

function activeLangsList(n){
  return LANG_ORDER2.slice(0, constrain(n,1,5));
}

function rebuildLexicon(n){
  const langs = activeLangsList(n);
  determiners   = [].concat(...langs.map(L=>LEX[L].DET));
  adjectives    = [].concat(...langs.map(L=>LEX[L].ADJ));
  singularNouns = [].concat(...langs.map(L=>LEX[L].NOUN));
  adverbs       = [].concat(...langs.map(L=>LEX[L].ADV));
  particles     = [].concat(...langs.map(L=>LEX[L].PREP));
  verbs3s       = [].concat(...langs.map(L=>LEX[L].VERB));
  extraPoeticWords = ["afterglow","echo","残響","霧","灯影","빛","光","mémoire"];

  words = Array.from(new Set([
    ...determiners, ...adjectives, ...singularNouns,
    ...adverbs, ...particles, ...verbs3s, ...extraPoeticWords
  ]));

  rebuildPOSets();

  let glyphs = langs.map(L=>LEX[L].GLYPHS).join("");
  makeBackground(glyphs.length ? glyphs : undefined);
}

function langsHuman(n){
  return activeLangsList(n).join("+");
}

// ---------- Setup & Draw ----------
function setup(){
  createCanvas(windowWidth,windowHeight);
  scaler=height/628; noSmooth();

  // DOM slider
  langSlider = createSlider(1,5,activeLangCount,1);
  langSlider.position(220, 12);
  langSlider.style('width', '220px');
  langSlider.input(onSliderChange);

  langLabel = createDiv("");
  langLabel.position(450, 6);
  langLabel.style('font-size','14px');
  langLabel.style('background','rgba(255,255,255,0.85)');
  langLabel.style('padding','6px 10px');
  langLabel.style('border-radius','8px');
  updateLangLabel();

  rebuildLexicon(activeLangCount);

  const savedData=loadMagnets();
  if(savedData===null){
    initFresh();
  }else{
    try{
      loadData(savedData);
      if(!magnets.some(m=>m.isInPoem)) makeEightWordPoem();
    }catch(e){
      clearMagnets();
      initFresh();
    }
  }
  textSize(16*scaler);
}

function updateLangLabel(){
  langLabel.html(\`Languages: \${activeLangCount} (\${langsHuman(activeLangCount)})\`);
}

function onSliderChange(){
  const newCount = langSlider.value();
  if(newCount === activeLangCount) return;
  activeLangCount = newCount;
  updateLangLabel();

  rebuildLexicon(activeLangCount);
  resetMagnetsToLexicon();
}

function initFresh(){
  loadData([]); magnets=[]; makeMagnets();
  for(let i=0;i<10;i++) spreadMagnets();
  initHomesFromCurrentPos();
  makeEightWordPoem(); saveMagnets(magnets);
}

function resetMagnetsToLexicon(){
  magnets = [];
  makeMagnets();
  for(let i=0;i<8;i++) spreadMagnets();
  initHomesFromCurrentPos();
  makeEightWordPoem();
  saveMagnets(magnets);
}

function draw(){
  background(246); image(bg,0,0);
  push(); translate(width/2,height/2);
  for(let m of magnets){ if(m!==selected) m.update(); m.show(); }
  pop();
  drawButtonsUI();
}

// ---------- Buttons UI ----------
function drawButtonsUI(){
  push(); noStroke();
  fill(255,240);
  rect(UI.shuffle.x,UI.shuffle.y,UI.shuffle.w,UI.shuffle.h,8);
  rect(UI.reset.x,UI.reset.y,UI.reset.w,UI.reset.h,8);
  fill(0); textAlign(LEFT,CENTER); textSize(14);
  text(UI.shuffle.label, UI.shuffle.x+10, UI.shuffle.y+UI.shuffle.h/2+1);
  text(UI.reset.label,   UI.reset.x+10,   UI.reset.y+UI.reset.h/2+1);
  pop();
}
function hit(r,x,y){ return (x>=r.x&&x<=r.x+r.w&&y>=r.y&&y<=r.y+r.h); }

// ---------- Magnets ----------
function makeMagnets(){
  for(let w of words){
    let pos=createVector(0,0);
    while(abs(pos.x)<0.2*width && abs(pos.y)<0.2*height){
      pos.x=random(-0.45*width,0.45*width);
      pos.y=random(-0.45*height,0.45*height);
    }
    const ang=random(-PI/32, PI/32);
    magnets.push(new Magnet(pos, w, ang));
  }
}
function spreadMagnets(){
  magnets.sort((a,b)=>(a.pos.x-b.pos.x));
  for(let m of magnets){
    for(let o of magnets){
      if(m.overlaps(o)&&m!=o){
        while((m.pos.x-m.dim.x/2)<(o.pos.x+o.dim.x/2)){ m.pos.x+=1; o.pos.x-=1; }
        m.target.x=m.pos.x; o.target.x=o.pos.x;
      }
    }
  }
}
function initHomesFromCurrentPos(){
  for(let m of magnets){
    m.home=m.pos.copy();
    m.setTarget(m.pos.x,m.pos.y,m.ang);
    m.isInPoem=false;
  }
}

// ---------- Templates (8 slots) ----------
const TEMPLATES_8 = [
  ["DET","ADJ","NOUN","PREP","ADV","NOUN","PREP","VERB3S"],
  ["DET","NOUN","PREP","ADJ","NOUN","PREP","ADV","VERB3S"],
  ["NOUN","PREP","DET","ADJ","NOUN","PREP","ADV","VERB3S"],
  ["DET","ADJ","NOUN","PREP","ADV","NOUN","PREP","VERB3S"]
];

function pickFromPOS(tag){
  switch(tag){
    case "DET":    return randomFrom(determiners);
    case "ADJ":    return randomFrom(adjectives);
    case "NOUN":   return randomFrom(singularNouns);
    case "VERB3S": return randomFrom(verbs3s);
    case "ADV":    return randomFrom(adverbs);
    case "PREP":   return randomFrom(particles);
    default:       return "";
  }
}

function chooseEnglishArticleFor(nextWord){
  const ch = String(nextWord||"").trim().charAt(0).toLowerCase();
  const vowels = "aeiou";
  return vowels.includes(ch) ? "an" : "a";
}

function makeEightWordPoem(){
  // send previous poem magnets home
  for(let m of magnets){
    if(m.isInPoem){
      m.isInPoem=false;
      m.displaySuffix="";
      m.displayOverride="";
      const tilt=random(-PI/32,PI/32);
      m.setTarget(m.home.x,m.home.y,tilt);
    }
  }

  const template = randomFrom(TEMPLATES_8);
  let chosenWords = template.map(tag => pickFromPOS(tag));

  // avoid immediate duplicate nouns
  for(let i=0;i<template.length;i++){
    if(template[i]==="NOUN" && i>0 && template[i-1]==="NOUN" && chosenWords[i-1]===chosenWords[i]){
      let n = pickFromPOS("NOUN");
      for(let j=0; j<6 && n===chosenWords[i-1]; j++) n = pickFromPOS("NOUN");
      chosenWords[i] = n;
    }
  }

  // English "a/an" fix
  for(let i=0;i<template.length;i++){
    if(template[i]==="DET"){
      const det = chosenWords[i];
      if(det==="a" || det==="an"){
        let lookahead = "";
        for(let j=i+1;j<template.length;j++){
          if(template[j]==="ADJ" || template[j]==="NOUN"){ lookahead = chosenWords[j]; break; }
        }
        chosenWords[i] = chooseEnglishArticleFor(lookahead);
      }
    }
  }

  // map to magnets
  const chosenMagnets = chosenWords.map(w => findMagnetByWord(w)).filter(Boolean);
  if(chosenMagnets.length !== chosenWords.length) return;

  // punctuation: '.' if last has latin, else '。'
  chosenMagnets.forEach(m=>{ m.displaySuffix=""; m.displayOverride=""; m.updateDimensions(); });
  const last = chosenMagnets[chosenMagnets.length-1];
  const lastSurface = last.getDisplayText();
  last.displaySuffix = /[A-Za-z]/.test(lastSurface) ? "." : "。";
  chosenMagnets.forEach(m=>m.updateDimensions());

  // center line
  const gap = 12 * scaler;
  const totalW = chosenMagnets.reduce((s,m)=>s+m.dim.x,0) + gap*(chosenMagnets.length-1);
  let xCursor = -totalW/2;
  const yLine = 0;

  for(let m of magnets) m.isInPoem=false;
  for(let m of chosenMagnets){
    m.isInPoem = true;
    m.setTarget(xCursor + m.dim.x/2, yLine, 0);
    xCursor += m.dim.x + gap;
  }
}

function findMagnetByWord(word){ return magnets.find(m => m.val === String(word)); }
function shufflePoem(){ makeEightWordPoem(); saveMagnets(magnets); }

// ---------- Interaction ----------
function mousePressed(){
  dragMoved=false;
  if(hit(UI.shuffle,mouseX,mouseY)){ shufflePoem(); return; }
  if(hit(UI.reset,mouseX,mouseY)){ resetEverything(); return; }

  const mx=mouseX-width/2, my=mouseY-height/2;
  for(let m of magnets){
    if(m.contains(mx,my)){
      offset=createVector(m.pos.x-mx,m.pos.y-my);
      selected=m; m.col=252; m.vel.set(0,0); m.angVel=0; break;
    }
  }
}
function mouseDragged(){
  if(selected){
    const mx=mouseX-width/2, my=mouseY-height/2;
    selected.pos.x=mx+offset.x; selected.pos.y=my+offset.y;
    selected.target.set(selected.pos.x,selected.pos.y); dragMoved=true;
  }
}
function mouseReleased(){
  for(let m of magnets){
    if(selected && selected.overlaps(m) && selected!=m){
      if(selected.pos.x>m.pos.x){
        while((selected.pos.x-selected.dim.x/2)<(m.pos.x+m.dim.x/2)) selected.pos.x+=1;
      }else{
        while((selected.pos.x+selected.dim.x/2)>(m.pos.x-m.dim.x/2)) selected.pos.x-=1;
      }
      selected.pos.y=m.pos.y; m.angTarget=0;
    }
  }
  if(selected){
    if(!dragMoved && selected.isInPoem){ swapWithinSamePOS(selected); saveMagnets(magnets); }
    selected.target.set(selected.pos.x,selected.pos.y);
    if(!selected.isInPoem) selected.home=selected.pos.copy();
    selected=null;
  }
  saveMagnets(magnets);
}
function keyPressed(){ if(key===' '||key==='S'||key==='s'){ shufflePoem(); return false; } }

// ---------- POS swap ----------
function swapWithinSamePOS(mag){
  const tag=posTag(mag.currentSurface());
  let pool=[];
  switch(tag){
    case POS.DET:  pool=determiners; break;
    case POS.ADJ:  pool=adjectives;  break;
    case POS.NOUN: pool=singularNouns; break;
    case POS.VERB3S: pool=verbs3s; break;
    case POS.ADV:  pool=adverbs; break;
    case POS.PREP: pool=particles; break;
    default: pool=[];
  }
  if(!pool.length) return;

  const current=mag.currentSurface();
  let candidate=randomFrom(pool), guard=0;
  while(candidate===current && guard<16){ candidate=randomFrom(pool); guard++; }

  const suffix=mag.displaySuffix;
  mag.displayOverride=candidate;
  mag.displaySuffix=suffix;
  mag.updateDimensions();
}

// ---------- Persistence ----------
function loadData(magnetsData){
  scaler=height/628; magnets=[];
  for(let m of (Array.isArray(magnetsData)?magnetsData:[])){
    const msc=(typeof m.scaler==='number'&&isFinite(m.scaler)&&m.scaler>0)?m.scaler:1;
    let x=(m.pos&&m.pos.x!=null)? m.pos.x*scaler/msc : 0;
    let y=(m.pos&&m.pos.y!=null)? m.pos.y*scaler/msc : 0;
    let val=(m.val!=null)? m.val : "";
    let ang=m.ang||0;
    let mm=new Magnet(createVector(x,y),val,ang);
    mm.displaySuffix=m.displaySuffix||"";
    mm.displayOverride=m.displayOverride||"";
    if(m.home && typeof m.home.x==='number' && typeof m.home.y==='number'){
      mm.home=createVector(m.home.x*scaler/msc,m.home.y*scaler/msc);
    }else{
      mm.home=mm.pos.copy();
    }
    mm.isInPoem=!!m.isInPoem;
    mm.setTarget(mm.pos.x,mm.pos.y,mm.ang);
    mm.updateDimensions();
    magnets.push(mm);
  }
}

function resetEverything(){
  clearMagnets();
  rebuildLexicon(activeLangCount);
  initFresh();
}

function windowResized(){
  resizeCanvas(windowWidth,windowHeight);
  scaler=height/628;
  rebuildLexicon(activeLangCount); // remakes background to new size
  const saved=loadMagnets();
  if(saved) loadData(saved);
}
  </script>
</body>
</html>
